#+TITLE: 100 Days Of Code - Log

* Day 0: October 05, 2018

** Today's Progress
+ Set up basic evironment
+ System: Mac Mojave
+ Editor: Emacs
+ Emacs dotfiles:
  
* Day 1: October 06, 2018

** Today's Progress
+ Finished Week one lessions video.
+ Set up Ocaml evironment with Emacs.
+ Write some basic ocaml code.
  
** Thoughts:
Ocaml is similar with Standard ML, And has lots of advantage.For example

The key additional ingredients
+ type inference: you don’t need to
write them!
+ pattern-matching: life saving data
manipulation feature!

In 2000 Jacques Garrigue’s extended Objective Label branch with
polymorphic methods, labeled and optional arguments, and polymorphic
variants, and In 2011 the name is definitely changed to Ocaml.

* Day 2: October 07, 2018

** Today's Progress
Read these materials.
[[http://palmstroem.blogspot.com/2012/05/lambda-calculus-for-absolute-dummies.html][The lanbda Calculus for Absolute Dummies]]
[[https://www.fun-mooc.fr/asset-v1:parisdiderot+56002+session03+type@asset+block/pdf_backus_turingaward_lecture.pdf][Can Programming Be Liberated from the von Neumann Style? A Functonal and ItsAlgebra of Programs]]

** Thoughts:
Turing Maching is designed for complicated calucations. It combing two parts ,
First is condition, Second is do, Just like If condition then do.


* Day 3: October 08, 2018 

** Today's Progress
+ Learn some basic ocaml syntax.
+ Read Real World Ocaml 
+ Try to install utop in Emacs, but not success
+ Write some notes about functional programming
  
** Thoughts:

 Why choose ocaml for learning.
 Beacuse, The learning curve of Ocaml is less than Haskell. and Ocaml is easy to
 work. For example, After finished ,I can choose Reasonml for further advance
 learning. Reasonml is created by Facebook, just like clojurescript,
 typescript.. Second Ocaml community is very nice to newbee, and As a Emacser
 can write ocaml than any other editor or IDE user. Third Ocaml is fu....ing insteresting. 

* Day 4: October 09, 2018

** Today's Progress
+ Read Real World Ocaml
+ Write somthing about Ocaml syntax
  
** Thoughts:

Programming languages have base types, like int, bool, and unit and 
Compound types.

+ “Each-of”: A compound type t describes values that contain each of values of type t1, t2, ..., and tn.
+ “One-of”: A compound type t describes values that contain a value of one of the types t1, t2, ..., or tn.
+ “Self-reference”: A compound type t may refer to itself in its definition in order to describe recursive data structures like lists and trees.

* Day 5: October 10, 2018

** Today's Progress
+ Read Real World Ocaml
+ Try to solve org-babel ocaml problem:
  Error: Unbound module Base
+ Learn something Ocaml syntax: Records and Variant, pattern-matching
+ Write notes about what I have learnt today
  
** Thoughts:

Ocaml is similar with Emacs in some field, For example, ocaml has init file
Named .ocamlinit. It helps ocaml load module, but something wrong with org-mode.
When I write some like this.

#+BEGIN_SRC ocaml
open Base;;

#+END_SRC

the results returned Error:
Error: Unbound module Base.

I set ocaml init file in current diretory, (.ocamlinit).

#+BEGIN_SRC ocaml


(* Ensure that we're in the root of the project. This is helpful for
   editor integration where the cwd might not be the root of the
   project.*)
let root =
  let rec search path = match Sys.file_exists (path ^ "/.ocamlinit") with
  | false -> search (Filename.dirname path)
  | true -> path
  in search (Sys.getcwd ())
in Sys.chdir root;;

#use "topfind";;
#require "batteries";;
#require "core";;
#require "async";;
#require "cohttp";;
#require "cohttp.async";;
#directory "_build";;

#+END_SRC

But the top of repl return error.

Cannot find file topfind.
Unknown directive 'require'

To sum up, may be tomorrow, I can fix this.

* Day 6: October 12, 2018

** Today's Progress
+ Read Real World Ocaml
+ Watch week two video
+ Do some exercise of week two
  
** Thoughts

I changed OCaml Repl to utop, It is a perpect tool to interactive with code.
Specially, Write code on org-mode, Maybe the most comfortable experience than
any other languages on org-mode.


* Day 7: October 13, 2018

** Today's Progress
+ Watch Week two video
+ Do some exercise of week two
+ Read why Functonal programming matters
  
** Thoughts 
Modularity is the key to successful programming, New scope rules and mechanisms
for seqarate compliation are not Enough.

To support module programming, a languages must provide good glue
Functonal programming languages provide two new kinds of glue
higher-order functions and lazy evaluation. So functional programs are so much
smaller and eaiser to write than conventional ones.

* Day 8: October 14, 2018

** Today's Progress

+ Watch Week three video
+ Finished Week two exercise
+ Read Real World OCaml
  
** Thoughts

 Records: Another Approach to “Each-of” Types
 
 Record types are “each-of” types where each component is a named field. For example, the type
{foo : int, bar : int*bool, baz : bool*int} describes records with three fields
named foo, bar, and baz. This is just a new sort of type, just like tuple types
were new when we learned them.A record expression builds a record value. For example, the expression
{bar = (1+2,true andalso true), foo = 3+4, baz = (false,9) } would evaluate to
the record value {bar = (3,true), foo = 7, baz = (false,9)}, which can have type
{foo : int, bar : int*bool, baz : bool*int} because the order of fields never
matters(we use the field names instead). In general the syntax for a record
expression is {f1 = e1, ..., fn = en} where,as always, each ei can be any
expression. Here each f can be any field name (though each must be different). 
A field name is basically any sequence of letters or numbers.
In ML, we do not have to declare that we want a record type with particular
field names and field types — we just write down a record expression and the
type-checker gives it the right type. The type-checking rules for record
expressions are not surprising: Type-check each expression to get some type ti
and then build the record type that has all the right fields with the right
types.Because the order of field names never matters, the REPL always
alphabetizes them when printing just for consistency.

* Day 9: October 15, 2018

** Today's Progess

+ Watch Week three video
+ Read Real World OCaml

** Thoughts
 Records and tuples are very similar. They are both "each-of" constructs that
 allow any number of components. The only real difference is that records are
 "by name" and tuples are "by position". This means with records we build them 
 and access their by using field name, But tuples access their by position.
 
 By name versus by poisition is a classic decision when designing a languages.

* Day 10: October 16, 2018

** Today's Progress

+ Watch Week three video
+ Read Real World OCaml
  
** Thoughts

1. When you write (e1, ..... , en) it is another way of writing
   {1=e1,....,n=en}, a tuple expression is a record expression with field names
   1,2,...n.
   
2. The type t1 * ... * tn is just another way of writing{1: t1,...,n:tn}
   
3. Notice that #1 2, #1 e, means: get the contents of field named 1, 2, etc.
   
Tuples are just syntacti sugar for records with fields named 1,2....,n
It is syntactic because we can descirbe everythng about tuples in terms of
equivalent record syntax. It is sygar beacuse it makes the language sweeter. The 
term syntactic sugar is widely used. Syntactic sygar is great way to keep the
key ideas in programming-language small

* Day 11: October 18, 2018

** Today's Progress
+ Read Real World OCaml
  
** Thoughts

Optional arguments in OCaml

#+BEGIN_SRC ocaml
let concat ?sep x y =
  let sep = match sep with None -> "" | Some x -> x in
  x ^ sep ^ y

#+END_SRC

#+RESULTS:
: val concat :
:   ?sep:Base.String.t -> Base.String.t -> Base.String.t -> Base.String.t =
:   <fun>

And also could same results

#+BEGIN_SRC ocaml
let concat ?(sep="") x y = x ^ sep ^ y
#+END_SRC

#+RESULTS:
: val concat :
:   ?sep:Base.String.t -> Base.String.t -> Base.String.t -> Base.String.t =
:   <fun>

when without optional arguments

#+BEGIN_SRC ocaml
concat "A" "B"

#+END_SRC

#+RESULTS:
: "AB"

Need optional arguments

#+BEGIN_SRC ocaml
concat ~sep:":" "A" "B"

#+END_SRC

#+RESULTS:
: "A:B"

#+BEGIN_SRC ocaml
concat "A" ~sep:":" "B"
 
#+END_SRC

#+RESULTS:
: "A:B"

When to erase optional arguments

#+BEGIN_SRC ocaml
let prepend_pound = concat "# "
#+END_SRC

#+RESULTS:
: <fun>

#+BEGIN_SRC ocaml
prepend_pound "a BASH comment"
#+END_SRC

#+RESULTS:
: "# a BASH comment"

#+BEGIN_SRC ocaml
prepend_pound "a BASH comment" ~sep:":" "Hello"
#+END_SRC

#+RESULTS:
: Characters 0-13:
:   prepend_pound "a BASH comment" ~sep:":" "Hello";;
:   ^^^^^^^^^^^^^
: Error: This function has type Base.String.t -> Base.String.t
:        It is applied to too many arguments; maybe you forgot a `;'.

Somthing Wrong happened.

 Characters 0-13:
   prepend_pound "a BASH comment" ~sep:":";;
   ^^^^^^^^^^^^^
 Error: This function has type Base.String.t -> Base.String.t
        It is applied to too many arguments; maybe you forgot a `;'.

Optional arguments is earsed as soon as the first positional arguments defined
after the optional argument is passed in 


* Day 12: October 19, 2018

** Today's Progress 
+ Just Read Real World Ocaml

** Thoughts

How ML Provides Access to Datatype Values: Case Expressions
In one sense, a case-expression is like a more powerful if-then-else expression
Like a conditional expression, it evaluates two of its subexpressions: first the 
expression between the case and of keywords and second the expression in the
first branch that matches. But instead of having two branches (one for true and one
for false), we can have one branch for each variant of our datatype (and we will generalize
this further below). Like conditional expressions, each branch’s expression must have
the same type (int in the example above) because the type-checker cannot know what
branch will be used.

* Day 13: October 20, 2018

** Today's Progress 
+ Read Real World OCaml

** Thoughts
+ List.fold is a very general and powerful function.
+ In ML language ,pattern matching is powerful than if statement

* Day 14: October 21, 2018

** Today's Progess
+ Read Real World Ocaml
+ Watch Week four videos
+ Learn Standard_ML
  
** Thoughts
+ How to writing efficient recursive functions in functional language
+ How to use accumulators as technigue to make some function tail recursive
  
#+BEGIN_SRC sml
fun sum1 xs = 
    case xs of 
        [] -> 0
     | i:xs' => i + sum1 xs';;

#+END_SRC

#+RESULTS:
: stdIn:10.12 Error: syntax error found at ARROW

#+BEGIN_SRC sml
fun sum2 xs = 
    let fun f (xs,acc) = 
            case xs of 
                [] -> acc
             | i::xs' => f(xs', i+acc)
    in 
        f(xs,0)
    end;;

#+END_SRC

#+RESULTS:
: stdIn:4.20 Error: syntax error found at ARROW

Both functions compute the same results, but sumw using a local helper function
takes an extra arguments, called acc for "accumulators"

* Day 15: October 22, 2018

** Today's Progress
+ Read Real World OCaml
+ Learn how to use Dune

** Thoughts 

Dune is something similar lein in Clojure. It is a project creater build our
app.
dune files are written using S-expressions (those lisp-y parentheses). Each of 
the top-level elements are called stanzas, and currently we have one stanzas.

Simplest usesage

+ Creat a Dun file 
  #+BEGIN_SRC scheme

  (executable
    (name main))

  #+END_SRC


+ Creat a ml file
  
  #+BEGIN_SRC ocaml

  let () = 
    print_endline "Hello, world"

  #+END_SRC
  
+ Build Dune
  
#+BEGIN_SRC sh
dune build main.exe

#+END_SRC

+ Finally run main.exe
  
#+BEGIN_SRC sh
dune exec ./main.exe

#+END_SRC

Hello, World!
