#+TITLE: 100 Days Of Code - Log

* Day 0: October 05, 2018

** Today's Progress
+ Set up basic evironment
+ System: Mac Mojave
+ Editor: Emacs
+ Emacs dotfiles:
  
* Day 1: October 06, 2018

** Today's Progress
+ Finished Week one lessions video.
+ Set up Ocaml evironment with Emacs.
+ Write some basic ocaml code.
  
** Thoughts:
Ocaml is similar with Standard ML, And has lots of advantage.For example

The key additional ingredients
+ type inference: you don’t need to
write them!
+ pattern-matching: life saving data
manipulation feature!

In 2000 Jacques Garrigue’s extended Objective Label branch with
polymorphic methods, labeled and optional arguments, and polymorphic
variants, and In 2011 the name is definitely changed to Ocaml.

* Day 2: October 07, 2018

** Today's Progress
Read these materials.
[[http://palmstroem.blogspot.com/2012/05/lambda-calculus-for-absolute-dummies.html][The lanbda Calculus for Absolute Dummies]]
[[https://www.fun-mooc.fr/asset-v1:parisdiderot+56002+session03+type@asset+block/pdf_backus_turingaward_lecture.pdf][Can Programming Be Liberated from the von Neumann Style? A Functonal and ItsAlgebra of Programs]]

** Thoughts:
Turing Maching is designed for complicated calucations. It combing two parts ,
First is condition, Second is do, Just like If condition then do.


* Day 3: October 08, 2018 

** Today's Progress
+ Learn some basic ocaml syntax.
+ Read Real World Ocaml 
+ Try to install utop in Emacs, but not success
+ Write some notes about functional programming
  
** Thoughts:

 Why choose ocaml for learning.
 Beacuse, The learning curve of Ocaml is less than Haskell. and Ocaml is easy to
 work. For example, After finished ,I can choose Reasonml for further advance
 learning. Reasonml is created by Facebook, just like clojurescript,
 typescript.. Second Ocaml community is very nice to newbee, and As a Emacser
 can write ocaml than any other editor or IDE user. Third Ocaml is fu....ing insteresting. 

* Day 4: October 09, 2018

** Today's Progress
+ Read Real World Ocaml
+ Write somthing about Ocaml syntax
  
** Thoughts:

Programming languages have base types, like int, bool, and unit and 
Compound types.

+ “Each-of”: A compound type t describes values that contain each of values of type t1, t2, ..., and tn.
+ “One-of”: A compound type t describes values that contain a value of one of the types t1, t2, ..., or tn.
+ “Self-reference”: A compound type t may refer to itself in its definition in order to describe recursive data structures like lists and trees.

* Day 5: October 10, 2018

** Today's Progress
+ Read Real World Ocaml
+ Try to solve org-babel ocaml problem:
  Error: Unbound module Base
+ Learn something Ocaml syntax: Records and Variant, pattern-matching
+ Write notes about what I have learnt today
  
** Thoughts:

Ocaml is similar with Emacs in some field, For example, ocaml has init file
Named .ocamlinit. It helps ocaml load module, but something wrong with org-mode.
When I write some like this.

#+BEGIN_SRC ocaml
open Base;;

#+END_SRC

the results returned Error:
Error: Unbound module Base.

I set ocaml init file in current diretory, (.ocamlinit).

#+BEGIN_SRC ocaml


(* Ensure that we're in the root of the project. This is helpful for
   editor integration where the cwd might not be the root of the
   project.*)
let root =
  let rec search path = match Sys.file_exists (path ^ "/.ocamlinit") with
  | false -> search (Filename.dirname path)
  | true -> path
  in search (Sys.getcwd ())
in Sys.chdir root;;

#use "topfind";;
#require "batteries";;
#require "core";;
#require "async";;
#require "cohttp";;
#require "cohttp.async";;
#directory "_build";;

#+END_SRC

But the top of repl return error.

Cannot find file topfind.
Unknown directive 'require'

To sum up, may be tomorrow, I can fix this.

* Day 6: October 12, 2018

** Today's Progress
+ Read Real World Ocaml
+ Watch week two video
+ Do some exercise of week two
  
** Thoughts

I changed OCaml Repl to utop, It is a perpect tool to interactive with code.
Specially, Write code on org-mode, Maybe the most comfortable experience than
any other languages on org-mode.


* Day 7: October 13, 2018

** Today's Progress
+ Watch Week two video
+ Do some exercise of week two
+ Read why Functonal programming matters
  
** Thoughts 
Modularity is the key to successful programming, New scope rules and mechanisms
for seqarate compliation are not Enough.

To support module programming, a languages must provide good glue
Functonal programming languages provide two new kinds of glue
higher-order functions and lazy evaluation. So functional programs are so much
smaller and eaiser to write than conventional ones.

* Day 8: October 14, 2018

** Today's Progress

+ Watch Week three video
+ Finished Week two exercise
+ Read Real World OCaml
  
** Thoughts

 Records: Another Approach to “Each-of” Types
 
 Record types are “each-of” types where each component is a named field. For example, the type
{foo : int, bar : int*bool, baz : bool*int} describes records with three fields
named foo, bar, and baz. This is just a new sort of type, just like tuple types
were new when we learned them.A record expression builds a record value. For example, the expression
{bar = (1+2,true andalso true), foo = 3+4, baz = (false,9) } would evaluate to
the record value {bar = (3,true), foo = 7, baz = (false,9)}, which can have type
{foo : int, bar : int*bool, baz : bool*int} because the order of fields never
matters(we use the field names instead). In general the syntax for a record
expression is {f1 = e1, ..., fn = en} where,as always, each ei can be any
expression. Here each f can be any field name (though each must be different). 
A field name is basically any sequence of letters or numbers.
In ML, we do not have to declare that we want a record type with particular
field names and field types — we just write down a record expression and the
type-checker gives it the right type. The type-checking rules for record
expressions are not surprising: Type-check each expression to get some type ti
and then build the record type that has all the right fields with the right
types.Because the order of field names never matters, the REPL always
alphabetizes them when printing just for consistency.
